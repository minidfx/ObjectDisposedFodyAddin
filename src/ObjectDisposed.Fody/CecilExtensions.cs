namespace ObjectDisposedFodyAddin
{
    using System;
    using System.CodeDom.Compiler;
    using System.Collections.Generic;
    using System.Linq;
    using System.Runtime.CompilerServices;

    using Mono.Cecil;
    using Mono.Cecil.Cil;

    /// <summary>
    ///     Extensions methods for the following <see cref="Type" />s:
    ///     <list type="bullet">
    ///         <item>
    ///             <term>
    ///                 <see cref="IEnumerable{T}" />
    ///             </term>
    ///         </item>
    ///         <item>
    ///             <term>
    ///                 <see cref="ICustomAttributeProvider" />
    ///             </term>
    ///         </item>
    ///     </list>
    /// </summary>
    public static class CecilExtensions
    {
        private static readonly IDictionary<string, MethodReference> CacheBaseMethodReferences = new Dictionary<string, MethodReference>();

        /// <summary>
        ///     Determines whether the dispose guard doesn't have to be injected into the method.
        /// </summary>
        /// <param name="typeDefinition">
        ///     The <see cref="Type" /> that we want to extend.
        /// </param>
        /// <returns>
        ///     <c>True</c> whether the method contains the attribute <see cref="SkipDisposeGuardAttribute" /> otherwise
        ///     <c>False</c>.
        /// </returns>
        public static bool SkipDisposeGuard(this TypeDefinition typeDefinition)
        {
            return typeDefinition.CustomAttributes.Any(x => x.AttributeType.FullName == "ObjectDisposedFodyAddin.SkipDisposeGuardAttribute");
        }

        /// <summary>
        ///     Determines whether a type has been generated by a tools.
        /// </summary>
        /// <param name="typeDefinition">
        ///     The <see cref="Type" /> that we want to extend.
        /// </param>
        /// <returns>
        ///     <c>True</c> whether the type contains the attribute <see cref="CompilerGeneratedAttribute" /> or
        ///     <see cref="GeneratedCodeAttribute" /> otherwise <c>False</c>.
        /// </returns>
        public static bool IsGeneratedCode(this TypeDefinition typeDefinition)
        {
            return typeDefinition.CustomAttributes.Any(a => a.AttributeType.Name == "CompilerGeneratedAttribute" || a.AttributeType.Name == "GeneratedCodeAttribute");
        }

        /// <summary>
        ///     Determimes whether the type contains at least a dispose method.
        /// </summary>
        /// <param name="typeDefinition">
        ///     The <see cref="Type" /> that we want to extend.
        /// </param>
        /// <returns>
        ///     <c>True</c> whether the type contains at least a dispose method otherwise <c>False</c>.
        /// </returns>
        public static bool HasDisposeMethod(this TypeDefinition typeDefinition)
        {
            return typeDefinition.HasMethods && typeDefinition.Methods.Any(x => x.Name == "Dispose" || x.Name == "DisposeAsync");
        }

        /// <summary>
        ///     Creates an override method into the <paramref name="typeDefinition" />.
        /// </summary>
        /// <param name="typeDefinition">
        ///     The <see cref="Type" /> that we want to extend.
        /// </param>
        /// <param name="name">
        ///     The name of the method.
        /// </param>
        /// <param name="returnType">
        ///     The return <see cref="Type" /> of the method.
        /// </param>
        public static void CreateOverrideMethod(this TypeDefinition typeDefinition,
                                                string name,
                                                TypeReference returnType)
        {
            const MethodAttributes OverrideMethodAttributes = MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.ReuseSlot | MethodAttributes.HideBySig;

            var newMethod = new MethodDefinition(name, OverrideMethodAttributes, returnType);
            var ilProcessor = newMethod.Body.GetILProcessor();
            var baseMethodReference = GetBaseMethod(typeDefinition);
            // How to create an override method : http://stackoverflow.com/a/8103611
            var instructions = Instructions.GetDefaultOverrideMethodInstructions(ilProcessor, baseMethodReference);

            ilProcessor.AppendRange(instructions);
            typeDefinition.Methods.Add(newMethod);
        }

        /// <summary>
        ///     Finds and returns the base dispose method.   
        /// </summary>
        /// <param name="originalTypeDefinition">
        ///     The <see cref="TypeDefinition"/> that needs the base <see cref="MethodReference"/>.
        /// </param>
        /// <returns>
        ///     The <see cref="MethodReference"/> that will be injected into the dipose method.
        /// </returns>
        private static MethodReference GetBaseMethod(TypeDefinition originalTypeDefinition)
        {
            var walkerTypeDefinition = originalTypeDefinition;
            MethodDefinition baseMethod = null;

            while (baseMethod == null && walkerTypeDefinition.BaseType != null)
            {
                var baseTypeFullName = walkerTypeDefinition.BaseType.FullName;
                if (CacheBaseMethodReferences.ContainsKey(baseTypeFullName))
                {
                    return CacheBaseMethodReferences[baseTypeFullName];
                }

                walkerTypeDefinition = walkerTypeDefinition.BaseType.Resolve();
                baseMethod = walkerTypeDefinition.Methods
                                                 .Where(x => x.Name == "Dispose" || x.Name == "DisposeAsync")
                                                 .SingleOrDefault(x => !x.Attributes.HasFlag(MethodAttributes.Private) &&
                                                                       !x.Attributes.HasFlag(MethodAttributes.Final));
            }

            if (baseMethod == null)
            {
                throw new WeavingException("Cannot found the base method for creating the override, make sure that the virtual keyword is present to one of a disposable method in any base classes.", WeavingErrorCodes.MustHaveVirtualKeyword);
            }

            var baseMethodReference = originalTypeDefinition.Module.Import(baseMethod);
            CacheBaseMethodReferences.Add(baseMethod.FullName, baseMethodReference);

            return baseMethodReference;
        }

        /// <summary>
        ///     Determines whether the <paramref name="typeDefinition" /> implements the interface <see cref="IDisposable" />.
        /// </summary>
        /// <param name="typeDefinition">
        ///     The <see cref="Type" /> that we want to extend.
        /// </param>
        /// <returns>
        ///     <c>True</c> whether the type implements the interface <see cref="IDisposable" /> otherwise <c>False</c>.
        /// </returns>
        public static bool HasIDisposableInterface(this TypeDefinition typeDefinition)
        {
            if (typeDefinition.Interfaces.Any(i => i.FullName == "System.IDisposable"))
            {
                return true;
            }

            if (typeDefinition.BaseType != null &&
                typeDefinition.BaseType != typeDefinition.Module.TypeSystem.Object &&
                typeDefinition.BaseType.IsDefinition)
            {
                // ReSharper disable once TailRecursiveCall
                return HasIDisposableInterface(typeDefinition.BaseType.Resolve());
            }

            return false;
        }

        /// <summary>
        ///     Determines whether the <paramref name="typeDefinition" /> implements the interface IAsyncDisposable.
        /// </summary>
        /// <param name="typeDefinition">
        ///     The <see cref="Type" /> that we want to extend.
        /// </param>
        /// <returns>
        ///     <c>True</c> whether the type implements the interface IAsyncDisposable otherwise <c>False</c>.
        /// </returns>
        public static bool HasIAsyncDisposableInterface(this TypeDefinition typeDefinition)
        {
            if (typeDefinition.Interfaces.Any(i => i.Name == "IAsyncDisposable"))
            {
                return true;
            }

            if (typeDefinition.BaseType != null &&
                typeDefinition.BaseType != typeDefinition.Module.TypeSystem.Object &&
                typeDefinition.BaseType.IsDefinition)
            {
                // ReSharper disable once TailRecursiveCall
                return HasIAsyncDisposableInterface(typeDefinition.BaseType.Resolve());
            }

            return false;
        }

        /// <summary>
        ///     Finds recursively the method
        /// </summary>
        /// <param name="typeDefinition">
        ///     The <see cref="Type" /> that we want to extend.
        /// </param>
        /// <param name="predicate">
        ///     A function to test an element for a condition.
        /// </param>
        /// <returns>
        ///     The <see cref="MethodDefinition" /> if the method is found with the <paramref name="predicate" /> otherwise
        ///     <c>null</c>.
        /// </returns>
        public static MethodDefinition GetMethodDefinition(this TypeDefinition typeDefinition,
                                                           Predicate<MethodDefinition> predicate)
        {
            MethodDefinition methodDefinition;
            return (methodDefinition = typeDefinition.Methods.SingleOrDefault(x => predicate(x))) != null
                       ? methodDefinition
                       : typeDefinition.BaseType != null
                             // ReSharper disable once TailRecursiveCall
                             ? GetMethodDefinition(typeDefinition.BaseType.Resolve(), predicate)
                             : null;
        }

        /// <summary>
        ///     Determines whether the <paramref name="typeDefinition" /> implements the interface <see cref="IDisposable" /> or
        ///     IAsyncDisposable.
        /// </summary>
        /// <param name="typeDefinition">
        ///     The <see cref="Type" /> that we want to extend.
        /// </param>
        /// <returns>
        ///     <c>True</c> whether the type implements the interface <see cref="IDisposable" /> or IAsyncDisposable otherwise
        ///     <c>False</c>.
        /// </returns>
        public static bool HasDisposeInterface(this TypeDefinition typeDefinition)
        {
            return HasIDisposableInterface(typeDefinition) || HasIAsyncDisposableInterface(typeDefinition);
        }

        /// <summary>
        ///     Inserts <paramref name="instructions" /> before the <paramref name="beforeInstruction" />.
        /// </summary>
        /// <param name="ilProcessor">
        ///     The <see cref="Type" /> that we want to extend.
        /// </param>
        /// <param name="beforeInstruction">
        ///     Inserts <paramref name="instructions" /> before this one.
        /// </param>
        /// <param name="instructions">
        ///     <see cref="Instructions" /> that will be inserted.
        /// </param>
        public static void InsertBeforeRange(this ILProcessor ilProcessor,
                                             Instruction beforeInstruction,
                                             IEnumerable<Instruction> instructions)
        {
            foreach (var instruction in instructions)
            {
                ilProcessor.InsertBefore(beforeInstruction, instruction);
            }
        }

        /// <summary>
        ///     Inserts <paramref name="instructions" /> at the start of the method.
        /// </summary>
        /// <param name="ilProcessor">
        ///     The <see cref="Type" /> that we want to extend.
        /// </param>
        /// <param name="instructions">
        ///     <see cref="Instructions" /> that will be inserted at the start of the method.
        /// </param>
        public static void AppendRange(this ILProcessor ilProcessor,
                                       IEnumerable<Instruction> instructions)
        {
            foreach (var instruction in instructions)
            {
                ilProcessor.Append(instruction);
            }
        }
    }
}