namespace ObjectDisposedFodyAddin.Extensions
{
    using System;
    using System.CodeDom.Compiler;
    using System.Collections.Generic;
    using System.Linq;
    using System.Runtime.CompilerServices;
    using System.Threading.Tasks;

    using Mono.Cecil;
    using Mono.Cecil.Cil;
    using Mono.Cecil.Rocks;

    public static class MethodDefinitionExtensions
    {
        /// <remarks>
        ///     How to create an override method : http://stackoverflow.com/a/8103611
        /// </remarks>
        public static void CreateOverride(this MethodReference methodReference,
                                          TypeDefinition typeDefinition,
                                          IEnumerable<Instruction> instructions)
        {
            const MethodAttributes OverrideMethodAttributes = MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.ReuseSlot | MethodAttributes.HideBySig;

            var newMethod = new MethodDefinition(methodReference.Name, OverrideMethodAttributes, methodReference.ReturnType);
            var ilProcessor = newMethod.Body.GetILProcessor();

            ilProcessor.AppendRange(instructions);

            typeDefinition.Methods.Add(newMethod);
        }

        /// <summary>
        ///     Continues the <see cref="Task" /> with an operation to set to disposed the object.
        /// </summary>
        /// <param name="methodDefinition">
        ///     The method that will be extended.
        /// </param>
        /// <param name="setToDisposedMethodReference">
        ///     The <see cref="MethodReference" /> of the method that will be called to set to disposed the method.
        /// </param>
        public static void AddSetIsDisposedAsync(this MethodDefinition methodDefinition,
                                                 MethodReference setToDisposedMethodReference)
        {
            var hasAsyncStateMachineAttribute = methodDefinition.CustomAttributes.Any(x => x.AttributeType.FullName.Equals("System.Runtime.CompilerServices.AsyncStateMachineAttribute"));
            var ilProcessor = methodDefinition.Body.GetILProcessor();
            var latestVariableInstruction = ilProcessor.GetLatestVariableInstruction();
            var callMethodInstruction = Instructions.GetCallMethodInstruction(ilProcessor, setToDisposedMethodReference, latestVariableInstruction);

            if (hasAsyncStateMachineAttribute)
            {
                foreach (var instruction in ilProcessor.Body.Instructions.Reverse().Take(3))
                {
                    ilProcessor.Remove(instruction);
                }

                ilProcessor.AppendRange(callMethodInstruction);
                ilProcessor.Append(ilProcessor.Create(OpCodes.Ret));
            }
            else
            {
                foreach (var instruction in ilProcessor.Body.Instructions.Reverse().ToArray())
                {
                    ilProcessor.Body.Instructions.Remove(instruction);

                    if (instruction.OpCode.Code == latestVariableInstruction.OpCode.Code)
                    {
                        break;
                    }
                }

                ilProcessor.AppendRange(callMethodInstruction);
                ilProcessor.Append(ilProcessor.Create(OpCodes.Ret));
            }

            methodDefinition.Body.OptimizeMacros();
        }

        /// <summary>
        ///     Set to disposed the object at the end of the method.
        /// </summary>
        /// <param name="methodDefinition">
        ///     The method that will be extended.
        /// </param>
        /// <param name="fieldReference">
        ///     The <see cref="FieldReference" /> that will be set to <see langword="True" />.
        /// </param>
        public static void AddSetIsDisposedSync(this MethodDefinition methodDefinition,
                                                FieldReference fieldReference)
        {
            var ilProcessor = methodDefinition.Body.GetILProcessor();

            ilProcessor.InsertBeforeRange(ilProcessor.Body.Instructions.Single(x => x.OpCode.Code == Code.Ret),
                                          Instructions.GetDisposeMethodPartialInstructions(ilProcessor, fieldReference));
        }

        /// <summary>
        ///     Determines whether a type has been generated by a tools.
        /// </summary>
        /// <param name="typeDefinition">
        ///     The <see cref="Type" /> that we want to extend.
        /// </param>
        /// <returns>
        ///     <c>True</c> whether the type contains the attribute <see cref="CompilerGeneratedAttribute" /> or
        ///     <see cref="GeneratedCodeAttribute" /> otherwise <c>False</c>.
        /// </returns>
        public static bool IsGeneratedCode(this IMemberDefinition typeDefinition)
        {
            return typeDefinition.CustomAttributes.Any(a => a.AttributeType.Name == "CompilerGeneratedAttribute" || a.AttributeType.Name == "GeneratedCodeAttribute");
        }

        /// <summary>
        ///     Determines whether a type has been generated by a tools.
        /// </summary>
        /// <param name="methodDefinition">
        ///     The <see cref="Type" /> that we want to extend.
        /// </param>
        /// <returns>
        ///     <c>True</c> whether the type contains the attribute <see cref="CompilerGeneratedAttribute" /> or
        ///     <see cref="GeneratedCodeAttribute" /> otherwise <c>False</c>.
        /// </returns>
        public static bool IsGeneratedCode(this MethodDefinition methodDefinition)
        {
            return IsGeneratedCode((IMemberDefinition)methodDefinition) && !(methodDefinition.IsGetter || methodDefinition.IsSetter);
        }
    }
}