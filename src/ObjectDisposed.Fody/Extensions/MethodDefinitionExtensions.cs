using System;
using System.CodeDom.Compiler;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Rocks;

namespace ObjectDisposed.Fody.Extensions
{
    /// <summary>
    ///     Contains extension methods for the any <see cref="MethodReference" />.
    /// </summary>
    public static class MethodDefinitionExtensions
    {
        /// <summary>
        ///     Continues the <see cref="Task" /> with an operation to set to disposed the object.
        /// </summary>
        /// <param name="methodDefinition">
        ///     The method that will be extended.
        /// </param>
        /// <param name="setToDisposedMethodReference">
        ///     The <see cref="MethodReference" /> of the method that will be called to set to disposed the method.
        /// </param>
        /// <param name="taskTypeReference"></param>
        public static void AddSetIsDisposedAsync(this MethodDefinition methodDefinition,
                                                 MethodReference setToDisposedMethodReference,
                                                 TypeReference taskTypeReference)
        {
            var ilProcessor = methodDefinition.Body.GetILProcessor();
            var continueTheTaskInstructions = Instructions.GetPartialContinueWithInstructions(ilProcessor, setToDisposedMethodReference, taskTypeReference)
                                                         .ToArray();

            var returnInstructions = ilProcessor.Body.Instructions
                                                .Where(x => x.OpCode.Code == Code.Ret)
                                                .ToArray();

            foreach (var returnInstruction in returnInstructions)
            {
                ilProcessor.InsertBeforeRange(returnInstruction, continueTheTaskInstructions);
            }

            methodDefinition.Body.OptimizeMacros();
        }

        /// <summary>
        ///     Set to disposed the object at the end of the method.
        /// </summary>
        /// <param name="methodDefinition">
        ///     The method that will be extended.
        /// </param>
        /// <param name="fieldReference">
        ///     The <see cref="FieldReference" /> that will be set to <see langword="True" />.
        /// </param>
        public static void AddSetIsDisposedSync(this MethodDefinition methodDefinition,
                                                FieldReference fieldReference)
        {
            var ilProcessor = methodDefinition.Body.GetILProcessor();
            var setToDisposedInstructions = Instructions.GetSetToDisposedMethodPartialInstructions(ilProcessor, fieldReference)
                                                        .ToArray();

            var returnInstructions = ilProcessor.Body
                                                .Instructions
                                                .Where(x => x.OpCode.Code == Code.Ret)
                                                .ToArray();

            foreach (var returnInstruction in returnInstructions)
            {
                ilProcessor.InsertBeforeRange(returnInstruction, setToDisposedInstructions);
            }

            ilProcessor.Body.OptimizeMacros();
        }

        /// <summary>
        ///     Determines whether a type has been generated by a tools.
        /// </summary>
        /// <param name="methodDefinition">
        ///     The <see cref="Type" /> that we want to extend.
        /// </param>
        /// <returns>
        ///     <c>True</c> whether the type contains the attribute <see cref="CompilerGeneratedAttribute" /> or
        ///     <see cref="GeneratedCodeAttribute" /> otherwise <c>False</c>.
        /// </returns>
        public static bool IsGeneratedCode(this MethodDefinition methodDefinition)
        {
            return methodDefinition.CustomAttributes.Any(a => a.AttributeType.Name == "CompilerGeneratedAttribute" || a.AttributeType.Name == "GeneratedCodeAttribute");
        }
    }
}